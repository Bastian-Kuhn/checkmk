#!/usr/bin/env python
# -*- coding: utf-8 -*- # Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# Sets/Removes downtimes via Check_MK Multisite Webservice
# Before you can use this script, please read:
# http://mathias-kettner.de/checkmk_multisite_automation.html
# And create an automation user - best with the name 'automation'
# And make sure that this user either has the admin role or is
# contact for all relevant objects.

# Restrictions / Bugs
# - When removing service downtimes the service names are interpreted
#   as regular expressions, but not when setting

import os
import sys
import getopt
import urllib
import ast

omd_site = os.getenv("OMD_SITE")
omd_root = os.getenv("OMD_ROOT")


def bail_out(reason):
    sys.stderr.write("Error: %s\n" % reason)
    sys.exit(1)

def warn_out(text):
    sys.stdout.write("Warning: %s\n" % text)

def verbose(text):
    if opt_verbose:
        sys.stdout.write("%s\n" % text)


def usage():
    sys.stdout.write("""Usage: downtime [OPTIONS] -H HOST/-G HOSTGROUP -S [SERVICE1, SERVICE2, ...]

This program sets and removes downtimes on hosts and services
via command line. If you run this script from within an OMD
site then most options will be guessed automatically. Currently
the script only supports cookie based login - no HTTP basic
authentication.

Before you use this script, please read:
http://mathias-kettner.de/checkmk_multisite_automation.html
You need to create an automation user - best with the name 'automation'
- and make sure that this user either has the admin role or is contact
for all relevant objects.

Options:
  -v, --verbose    Show what's going on (specify twice for more verbose output)
  -m, --mode       Either add or remove
  -f, --force      Removal all downtimes without filtering by current user when not using comment filter
  -A, --add        Short form of --mode 'add'
  -R, --remove     Short form of --mode 'remove'
  -t, --target     Target host, hostgroup, service, servicegroup
  -H  --host       Hostname
  -G  --group      Group
  -S  --services   Services
  -c, --comment    Comment for the downtime or filter expr. when mode remove
  -d, --duration   Duration of the downtime in minutes (default: 120)
  -h, --help       Show this help and exit
  -u, --user       Name of automation user (default: "automation")
  -s, --secret     Automation secret (default: read from user settings)
  -U, --url        Base-URL of Multisite (default: guess local OMD site)
  -T, --timerange  Fixed Timerange like: "2020-05-29T14:30 2020-05-30T17:00"
""")


short_options = 'vhARfm:H:G:S:t:c:l:d:u:s:U:T:'
long_options = [
    "verbose", "help", "add", "remove", "mode=", "host=", "group=", "services=", "target=", "comment=",
    "url=", "duration=", "user=", "secret=", "force", "timerange="
]

opt_verbose = 0
opt_mode = "add"
opt_target = "host"
#opt_comment = "Automatic downtime"
opt_comment = None
opt_user = "automation"
opt_secret = None
opt_url = ""
opt_duration = 120
opt_group = None
opt_host = None
opt_services = ""
opt_force = False
opt_timerange = ""

if omd_site:
    opt_url = "http://localhost/" + omd_site + "/check_mk/"
try:
    opts, args = getopt.getopt(sys.argv[1:], short_options, long_options)
except getopt.GetoptError as err:
    sys.stderr.write("%s\n\n" % err)
    usage()
    sys.exit(1)

if len(sys.argv[1:]) == 0:
    usage()
    sys.exit(1)

for o, a in opts:
    # Docu modes
    if o in ['-h', '--help']:
        usage()
        sys.exit(0)

    # Modifiers
    elif o in ['-v', '--verbose']:
        opt_verbose += 1
    elif o in ['-m', '--mode']:
        opt_mode = a
    elif o in ['-A', '--add']:
        opt_mode = 'add'
    elif o in ['-R', '--remove']:
        opt_mode = 'remove'
    elif o in ['-t', '--target']:
        opt_target = a
    elif o in ['-c', '--comment']:
        opt_comment = a
    elif o in ['-d', '--duration']:
        opt_duration = int(a)
    elif o in ['-u', '--user']:
        opt_user = a
    elif o in ['-s', '--secret']:
        opt_secret = a
    elif o in ['-U', '--url']:
        opt_url = a
    elif o in ['-S', '--services']:
        opt_services = a
    elif o in ['-G', '--groups']:
        opt_group = a
    elif o in ['-H', '--host']:
        opt_host = a
    elif o in ['-f', '--force']:
        opt_force = True
    elif o in ['-T', '--timerange']:
        opt_timerange = a
    else:
        bail_out("Option '" + o + "' is unknown.")

if opt_target in ["host", "service"]:
    if not opt_host:
        bail_out("Please specify a Host with -H.")
    if opt_group:
        warn_out("Option '-G group' is ignored when used in combination with Option '-t %s'." % opt_target)

if opt_target in ["hostgroup", "servicegroup"] and not opt_group:
    bail_out("Please specify a Group -G.")

if opt_target == "service" and not opt_services:
    bail_out("Please specify a Services with -S.")

if opt_services and opt_target in ["host", "hostgroup", "servicegroup"]:
    warn_out("Option '-S service' is ignored when used in combination with Option '-t %s'." % opt_target)

if not opt_url or opt_user.startswith("http"):
    bail_out("Please specify the URL to Check_MK Multisite with -U (uppercase).")

if not opt_url.endswith("/check_mk/"):
    bail_out("The automation URL must end with '.../check_mk/'.")

if not opt_user:
    bail_out("Please specify the automation user to use with -u (lowercase).")

if omd_site and not opt_secret:
    try:
        opt_secret = open( str(omd_root) + "/var/check_mk/web/" + str(opt_user) + "/automation.secret" ).read().strip()
    except Exception as e:  #pylint: disable=broad-except
        bail_out("Cannot read automation secret from user %s: %s." % (opt_user, e))

elif not omd_site and not opt_secret:
    bail_out("Please specify the automation secret for the user '%s' with -s!" % opt_user)

if opt_verbose > 1:
    verbose("Multisite-URL: " + opt_url)
verbose("User:          " + opt_user)
if opt_verbose > 2:
    verbose("Secret:        " + (opt_secret or "(none specified)"))


def make_url(base, url_variables):
    vartext = "&".join(["%s=%s" % (varname, urllib.quote(value)) for (varname, value) in url_variables])
    return base + "?" + vartext


def make_request(url_variables):
    url = make_url(opt_url + "view.py", url_variables)
    if opt_verbose > 1:
        verbose("URL:           " + url)
    try:
        pipe = urllib.urlopen(url)
        raw = pipe.read()
        lines = raw.split('\n')
        if opt_verbose > 1:
            verbose(" --> Got %d lines of response" % len(lines))
        if opt_verbose > 2:
            for line in lines:
                verbose("OUTPUT: %s" % line.rstrip())
        for line in lines:
            if "HINWEIS" in line:
                sys.stdout.write(line + "\n")
            if line.startswith("<div class=error>"):
                bail_out(line[17:].split("<")[0])
        return raw
    except Exception as e:  #pylint: disable=broad-except
        bail_out("Cannot call Multisite URL: %s." % e)


# Authentication and host selection
variables = [
    ("_username", opt_user),
    ("_secret", opt_secret),
    ("_transid", "-1"),
    ("_do_confirm", "yes"),
    ("_do_actions", "yes"),
]

if opt_mode == "add":

    # Check Options
    if not opt_duration:
        bail_out("Please specify duration (-d).")
    if not opt_comment:
        opt_comment = "Automatic downtime set by %s script." % os.path.splitext(os.path.basename(sys.argv[0]))[0]

    # Add Downtimes
    verbose("Modus:         Add Downtime")
    verbose("Target:        %s" % opt_target)
    verbose("Comment:       %s" % opt_comment)
    variables += [
        ("_down_comment", opt_comment),
    ]

    if opt_timerange:
        verbose("Timerange:      %s" % opt_timerange)
        start, end = opt_timerange.split()
        start_date, start_time = start.split("T")
        end_date, end_time = end.split("T")

        variables.append(("_down_from_date", start_date))
        variables.append(("_down_from_time", start_time))
        variables.append(("_down_to_date", end_date))
        variables.append(("_down_to_time", end_time))
        variables.append(("_down_custom", "Custom time range"))
    else:
        variables.append(("_down_from_now", "yes"))
        variables.append(("_down_minutes", str(opt_duration)))
        verbose("Duration:      %dm" % opt_duration)

    if opt_target == "host":
        verbose("Host:          %s" % opt_host)
        variables.append(("host", opt_host))
        variables.append(("view_name", "hoststatus"))
        variables.append(("output_format", "python"))
        make_request(variables)

    elif opt_target == "hostgroup":
        verbose("Hostgroup:     %s" % opt_group)
        variables.append(("hostgroup_regex", opt_group))
        variables.append(("view_name", "hostsbygroup"))
        variables.append(("output_format", "python"))
        make_request(variables)

    elif opt_target == "servicegroup":
        verbose("Servicegroup:  %s" % opt_group)
        variables.append(("servicegroup", opt_group))
        variables.append(("view_name", "servicegroup"))
        variables.append(("output_format", "python"))
        make_request(variables)

    elif opt_target == "service":
        verbose("Host:          %s" % opt_host)
        variables.append(("host", opt_host))
        variables.append(("view_name", "service"))
        variables.append(("output_format", "python"))
        for service in [x.strip() for x in opt_services.split(',')]:
            verbose("Service:       %s" % service)
            make_request(variables + [("service", service)])

    else:
        bail_out("Target '%s' unkown." % opt_target)

elif opt_mode == "remove":

    # Remove Downtimes
    verbose("Modus:         Remove Downtime")
    verbose("Target:        %s" % opt_target)
    variables += [
        ("_remove_downtimes", "Remove"),
    ]

    if opt_comment:
        verbose("Limit by:      %s" % opt_comment)
        variables.append(("downtime_comment", opt_comment))
    elif opt_force:
        verbose("Remove Dowtimes without limit")
    else:
        verbose("Limit by current user (%s)" % (opt_user))
        variables.append(("downtime_author", opt_user))

    if opt_target == "host":
        verbose("Host:          %s" % opt_host)
        variables.append(("host", opt_host))
        variables.append(("is_service_scheduled_downtime_depth", '0'))
        variables.append(("view_name", "downtimes"))
        variables.append(("output_format", "python"))
        make_request(variables)

    elif opt_target == "hostgroup":
        verbose("Hostgroup:     %s" % opt_group)
        # Frist search for a list of affected hosts
        search_variables = [
            ("hostgroup", opt_group),
            ("output_format", "python"),
            ("view_name", "hostsbygroup"),
        ]
        objects = make_request(variables + search_variables)

        variables.append(("view_name", "downtimes"))
        variables.append(("is_service_scheduled_downtime_depth", '0'))
        variables.append(("output_format", "python"))
        for entry in ast.literal_eval(objects)[1:]:
            verbose("Host:          %s" % entry[1])
            make_request(variables + [("host", entry[1])])

    elif opt_target == "servicegroup":
        verbose("Servicegroup:  %s" % opt_group)
        search_variables = [
            ("servicegroup", opt_group),
            ("output_format", "python"),
            ("view_name", "svcbygroups"),
        ]
        # get list of matching service downtimes
        objects = make_request(variables + search_variables)

        variables.append(("view_name", "downtimes_of_service"))
        variables.append(("output_format", "python"))
        for entry in ast.literal_eval(objects)[1:]:
            host = entry[0]
            service = entry[2]
            verbose("Host:          %s" % host)
            verbose("Service:       %s" % service)
            make_request(variables + [("host", host), ("service", service)])

    elif opt_target == "service":
        verbose("Host:          %s" % opt_host)
        variables.append(("host", opt_host))
        variables.append(("view_name", "downtimes_of_service"))
        variables.append(("output_format", "python"))
        for service in [x.strip() for x in opt_services.split(',')]:
            verbose("Service:       %s" % service)
            make_request(variables + [("service", service)])
    else:
        bail_out("Target '%s' unkown" % opt_target)

else:
    bail_out("Mode '%s' unknwon" % opt_mode)
